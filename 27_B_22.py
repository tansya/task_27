f = open('27_B_22.txt','r')
P = [0] #создали префиксный массив с единственным нулевым элементом
N = int(f.readline()) # считываем количество элементов в последовательности
for i in range(N):
    x = int(f.readline()) # считываем по одному числовому элементу
    P.append(P[-1] + x) # добавляем в префикный массив новое значение
f.close()
A = [0] * 43 # создаем дополнительный массив, в котором элементы соответствуют остатку  
mx_sm = 0 # максимальная сумма
ans = 0 # ответ - наилучшая длина подполедовательности с максимальной суммой
for i in range(1,len(P)):
    mod = P[i] % 43 # остаток для текущего элемента префиксного массива
    if mod != 0: # нулевой остаток как ислючение
        if A[mod] == 0: # остаток встретился впервые
            A[mod] = [P[i],i] # запомнили для первого вхождения пару величин
        else: 
            if P[i] - A[mod][0] > mx_sm: # при заполненном элементе проверяем лучшую сумму
                mx_sm = P[i] - A[mod][0] # меняем лучшую сумму
                ans = i - A[mod][1] # запоминаем новый ответ для лучшей суммы
            elif P[i] - A[mod][0] == mx_sm: # в случае равенства лучшей суммы
                ans = min(ans, i - A[mod][1]) # выбираем лучшую длину
    else:
        mx_sm = P[i] # для нулевого остатка сумма и длина всегда наилучшая
        ans = i # запомнили лучшую длину
print(ans)
#ans = 329329
